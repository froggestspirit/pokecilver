#include "../constants.h"

int Random(){
	SET_PC(0x30A0U);
//  A simple hardware-based random number generator (RNG).

//  Two random numbers are generated by adding and subtracting
//  the divider to the respective values every time it's called.

//  The divider is a register that increments at a rate of 16384Hz.
//  For comparison, the Game Boy operates at a clock speed of 4.2MHz.

//  Additionally, an equivalent function is executed in VBlank.

//  This leaves a with the value in hRandomSub.

	PUSH_BC;  // push bc

	LDH_A_addr(rDIV);  // ldh a, [rDIV]
	LD_B_A;  // ld b, a
	LDH_A_addr(hRandomAdd);  // ldh a, [hRandomAdd]
	ADC_A_B;  // adc b
	LDH_addr_A(hRandomAdd);  // ldh [hRandomAdd], a

	LDH_A_addr(rDIV);  // ldh a, [rDIV]
	LD_B_A;  // ld b, a
	LDH_A_addr(hRandomSub);  // ldh a, [hRandomSub]
	SBC_A_B;  // sbc b
	LDH_addr_A(hRandomSub);  // ldh [hRandomSub], a

	POP_BC;  // pop bc
	RET;  // ret

}

int BattleRandom(){
	SET_PC(0x30B3U);
//  _BattleRandom lives in another bank.

//  It handles all RNG calls in the battle engine, allowing
//  link battles to remain in sync using a shared PRNG.

	LDH_A_addr(hROMBank);  // ldh a, [hROMBank]
	PUSH_AF;  // push af
	LD_A(BANK(av_BattleRandom));  // ld a, BANK(_BattleRandom)
	RST(mBankswitch);  // rst Bankswitch

	CALL(mv_BattleRandom);  // call _BattleRandom

	LD_addr_A(wPredefHL + 1);  // ld [wPredefHL + 1], a
	POP_AF;  // pop af
	RST(mBankswitch);  // rst Bankswitch
	LD_A_addr(wPredefHL + 1);  // ld a, [wPredefHL + 1]
	RET;  // ret

}

int RandomRange(){
	SET_PC(0x30C5U);
//  Return a random number between 0 and a (non-inclusive).

	PUSH_BC;  // push bc
	LD_C_A;  // ld c, a

// ; b = $100 % c
	XOR_A_A;  // xor a
	SUB_A_C;  // sub c

mod:
	SET_PC(0x30C9U);
	SUB_A_C;  // sub c
	IF_NC goto mod;  // jr nc, .mod
	ADD_A_C;  // add c
	LD_B_A;  // ld b, a

// ; Get a random number
// ; from 0 to $ff - b.
	PUSH_BC;  // push bc

loop:
	SET_PC(0x30CFU);
	CCALL(aRandom);  // call Random
	LDH_A_addr(hRandomAdd);  // ldh a, [hRandomAdd]
	LD_C_A;  // ld c, a
	ADD_A_B;  // add b
	IF_C goto loop;  // jr c, .loop
	LD_A_C;  // ld a, c
	POP_BC;  // pop bc

	CCALL(aSimpleDivide);  // call SimpleDivide

	POP_BC;  // pop bc
	RET;  // ret

}

